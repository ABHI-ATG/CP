// Dont foget
// disconnected graph



/*-----------------------tree----------------------*/


/*
1.
With respect to two nodes a and b, if we want two nodes x and y closer to each other
sort according to d1[x]a - d2[x]b
example-  
    Before
                d
        a   c  e  g   b
                f
    After:
        a c d f e g b


2.
// the number of time an edge is used for each pair of distance between node is f*s;
// where f- the nodes prior to that node ans s- nodes which is after including that node;
// 


3.
// bipartite graph
//

4.
// most of the path problems can be solved by binary lifting
// 



5.
euler tour : flat tree concept (tin and tout)

tin, tout :
can be used for a path from node to root
can be used for subtree also

6.
Centroid and Heavy Light



/*-----------------------graph----------------------*/

/*

//
// detect cycle in directed graph

//
// for directed graph
// use incoming edges concept 
// also push all edges in queue having incoming edge as 0; (beware of this)
// 


// 
// binary lifting 
// find each bit parent of a node if there is a cycle 
// for(int i=0;i<ln;i++) then do computing


// bellman ford
// last iteration : you can find the negative weight cycle
// all the node of negative weight cycle will update in the last iteration
// during update, you can store the parent of each node of cycle, storing the parent also form the cycle
// if condition of negative weight cycle is satisfied in the last iteration then it not means that the node is a part of cycle

*/


/*
Strongly Connected Component : directed graph having a cycle
// find topological sorting (in case of cycle also)
// then make the component (basically all the nodes which are the part of cycle) as single node and make a new graph
// then you will have a directed graph having no cycle


*/